---
layout: kb
permalink: /kb/d0085167-8832-466b-8cba-cc2e377e84c3
title: Экономное кодирование информации по алгоритму Хаффмана
excerpt:
image:
date: 2009-06-09 16:21:44 UTC
tags: кодирование информации
sections: статья
---

<p>Рассматриваются алгоритм<span>Хаффмана в двоичной и троичной системе, производится анализ эффективности,  описываются особенности реализации.</span></p>
<h2>Алгоритм Хаффмана</h2>
<p>Алгоритм служит для получения префиксных кодов — кодов переменной длины, которые позволяют осуществлять экономное кодирование информации.</p>
<p>Например, при экономном кодировании символьной информации часто встречаемые символы кодируются короткими кодами, в то время как редко встречающиеся — длинными.</p>
<p>Префиксные коды и алгоритмы их получения подробно описаны в монографии Семенюка В. В. «Экономное кодирование дискретной информации<span>» [1].</span></p>
<h2>Алгоритм Хаффмана для двоичной системы</h2>
<ol>
<li>Вычисляем вероятность появления каждого символа в информации</li>
<li>Каждому символу присваивается значение равное его частоте вхождения</li>
<li>Полученный список элементов (пара символ — значение) сортируется<span>по убыванию: от часто встречаемых к менее встречаемым</span></li>
<li>Два последних элемента списка объединяются в новый элемент, значение которого равно сумме значений вошедших в него элементов, т.е. вместо двух<span>последних</span>элементов записывается новый</li>
<li>Новый список сортируется по убыванию</li>
<li>Операции 4, 5 выполняются до тех пор? пока не останется один элемент</li>
<li>Выписывается последний оставшейся элемент</li>
<li>От него откладывают две ветви с элементами, которые его составляют</li>
<li>От каждого элемента, если он не является символом, откладываются такие же две ветви с входящими в него элементами</li>
<li>Процесс выполняется до тех пор, пока все элементы не будут выписаны</li>
<li>Каждому ребру назначается коды 0 и 1</li>
<li>Для каждого символа<span>(не элемента)</span>в дереве выписывается префиксный код, как последовательность кодов рёбер идущих от вершины к символу</li>
</ol>
<h2>Особенности алгоритма Хаффмана для троичной системы</h2>
<p>Алгоритмы Хаффмана для двоичной и троичной системы аналогичны.</p>
<p>Однако есть ряд отличий и особенностей.</p>
<p>Так, вместо объедения двух последних элементов, при кодировании в троичной системе объединяются три.</p>
<p>Так как объединяется нечётное количество элементов, в некоторых случаях может оказаться, что при последнем объедении будут объединяться не три, а только два элемента, что повлечёт серьёзные потери в эффективности. Это связано с тем одна из самых верхней ветвей окажется пустой. Существует способ переместить пустую ветвь на самый низкий уровень, что позволит полностью избежать потери в эффективности. Для этого необходимо учитывать количество элементов в первоначальном списке. В случае если количество элементов чётное, то на первом шаге необходимо объединять не три, а два элемента (на следующих шаг объединяются три). Таким образом, пустая ветвь будет на самом низком уровне, где находятся самые редко встречаемые элементы. В случае если количество элементов  в первоначальном списке нечётно, то и на первом шаге объединяется три элемента.</p>
<p>Доказательство.<span>Так как при объединении трех элементов одним получаем список меньше предыдущего на два элемента и, учитывая условие, что на последнем этапе необходимо, чтобы объединилось три элемента, получим, что эффективно будет кодироваться список 3+2·k элементами, т.е. с нечётным количеством элементов.  Поэтому при четном количестве элементов — 3 + 2k + 1 — первоначально объединяются два элемента, т.е. получаем список с (3 + 2k) элементов — с нечетным количеством элементов.</span></p>
<h2>Алгоритм Хаффмана для троичной системы</h2>
<ol>
<li>Вычисляем вероятность появления каждого символа в информации</li>
<li>Каждому символу присваивается значение равное его частоте вхождения</li>
<li>Полученный список элементов (пара символ — значение) сортируется<span>по убыванию:</span>от часто встречаемых к менее встречаемым</li>
<li>Определяется количество элементов в списке</li>
<li>Если количество элементов чётно, то<span>в новый элемент</span><span>объединяются</span>два последних элемента списка, если количество нечётно — объединяются три элемента, значение нового элемента равно сумме значений вошедших в него элементов</li>
<li>Новый список сортируется по убыванию</li>
<li>Три последних элемента объединяются в новый</li>
<li>Новый список сортируется по убыванию</li>
<li>Операции 7,8 выполняются до тех пор, пока не останется один элемент</li>
<li>Выписывается последний оставшейся элемент</li>
<li>От него откладывают три ветви с элементами, которые его составляют</li>
<li>От каждого элемента, если он не является символом, откладываются такие же три ветви с входящими в него элементами.</li>
<li>Процесс выполняется до тех пор, пока все элементы не будут выписаны</li>
<li>Каждому ребру назначается коды -, 0 и +</li>
<li>Для каждого символа<span>(не элемента)</span>в дереве выписывается префиксный код, как последовательность кодов рёбер идущих от вершины к символу</li>
</ol>
<h2>Построение двоичного и троичного кодового дерева</h2>
<p>Рассмотрим построения двоичного и троичного кодовых деревьев по алгоритму Хаффмана.</p>
<p>Кодируемое сообщение: «ГОЛОГРАММА».</p>
<p>Статистика появления символов в сообщении: Г(2), О(2), Л(1), Р(1), A(2), М(2).</p>
<p>Упорядоченный список: A(2), Г(2), М(2), О(2), Л(1), Р(1).</p>
<table>
<tbody>
<tr>
<td>Кодирование в двоичной системе</td>
<td>Кодирование в троичной системе</td>
</tr>
<tr>
<td><p>
<img alt="" src="/images/article.huffman.codeinbin.png" />
</p>
<p></p>
<p>Двоичное дерево Хаффмана</p>
<div>
<img alt="" src="/images/article.huffman.bintree.png" />
</div>
<p></p>
</td>
<td><p>
<img alt="" src="/images/article.huffman.codeintrinary.png" />
</p>
<p></p>
<p>Троичное дерево Хаффмана</p>
<div>
<img alt="" src="/images/article.huffman.trinarytree.png" />
</div>
<p></p>
<p><span>Примечание.</span>Список состоит из 6 элементов — количество четное — на первом шаге объединяем только два последних элемента.</p>
</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<td rowspan="2">Символ</td>
<td rowspan="2">Частота</td>
<td colspan="3">Двоичная система</td>
<td colspan="3">Троичная система</td>
</tr>
<tr>
<td>Префиксный код</td>
<td>Длина кода</td>
<td>Сумма</td>
<td>Префиксный код</td>
<td>Длина кода</td>
<td>Сумма</td>
</tr>
</thead>
<tbody>
<tr>
<td>А</td>
<td>2</td>
<td>10</td>
<td>2</td>
<td>4</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>Г</td>
<td>2</td>
<td>11</td>
<td>2</td>
<td>4</td>
<td>--</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>М</td>
<td>2</td>
<td>000</td>
<td>3</td>
<td>6</td>
<td>-0</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>О</td>
<td>2</td>
<td>001</td>
<td>3</td>
<td>6</td>
<td>-+</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>Л</td>
<td>1</td>
<td>010</td>
<td>3</td>
<td>3</td>
<td>+-</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>Р</td>
<td>1</td>
<td>011</td>
<td>3</td>
<td>3</td>
<td>+0</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td>Итого:</td>
<td>26</td>
<td> </td>
<td>Итого:</td>
<td>18</td>
</tr>
</tbody>
</table>
<h2>Сравнение алгоритма для двоичной и троичной систем</h2>
<p>Оценим количество шагов для построения деревьев.</p>
<table>
<tbody>
<tr>
<td>Кодирование в двоичной системе</td>
<td>Кодирование в троичной системе</td>
</tr>
<tr>
<td>Пусть L = 2n (n — натуральное число) — количество элементов в первоначальном списке, K — количество шагов (K — натуральное число). На каждом шаге происходит объединение 2-х элементов в 1, — список с каждым шагом уменьшается на 1 элемент. Таким образом, на предпоследнем шаге останется 2 элемента, т.е. L-(K-1) = 2. Таким образом, K = L – 1 = 2n -1.</td>
<td>Первоначально рассмотрим случай, когда количество элементов в первоначальном списке чётно, L = 2n (n — натуральное число) — количество элементов в первоначальном списке, K — количество шагов (K — натуральное число). На каждом шаге происходит объединение 3-х элементов в 1, т.е. список с каждым шагом уменьшается на 1 элемент. Однако в соответствии с оптимальным алгоритмом на первом шаге необходимо объединять в один элемент 2, а не 3.   Будем считать, что первый шаг выполнен, было объединено только 2 элемента в 1 (L-1). Таким образом, на предпоследнем шаге останется 3 элемента, т.е. L-2*(K-2) - 1= 3. Таким образом, K = L – 1 = 2n -1.</td>
</tr>
</tbody>
</table>
<p>Оценим эффективность построения деревьев.</p>

<table>
<tbody>
<tr>
<td>Кодирование в двоичной системе</td>
<td>Кодирование в троичной системе</td>
</tr>
<tr>
<td>Каждый уровень дерева может содержать до 2<span>n</span><span>элементов, где n</span><span>― номер уровня, т.е. 1-ый уровень содержит 2 элемента, 2-ой ― 4, 3-ий ― 8, 10-ый уровень может содержать уже 2</span><span>10</span><span>, т.е 1024 элементов.</span></td>
<td>Каждый уровень дерева может содержать до 3<span>n</span><span>элементов. Таким образом, 10-ый уровень может содержать 3</span><span>10</span><span>, т.е 59049 элементов.</span></td>
</tr>
</tbody>
</table>

<p>Порядок уровня определяет длину префиксного кода. Например, длина префиксных кодов элементов 1-го уровня равна 1, 7-ого<span>― 7</span>. Соответственно, чем меньше уровней будет в дереве, тем более экономичным будет кодирование.</p>
<p>Рассмотрим случай, когда все кодируемые элементы располагаются на последнем уровне, случай, когда первоначально все элементы имеют одинаковый вес.</p>
<p>Так на 9-й уровень при кодировании в троичной системе может содержать до 19683 элементов, при кодировании в двоичной системе 9-й уровень может содержать только 512. Лишь 14-й уровень будет содержать примерно такое же количество элементов (15-й уровень будет уже содержать большее, чем 9-й при троичном кодировании). Относительную эффективность можно оценить по соотношению уровней. Из приведённой ниже таблицы видно, что, в среднем, кодирование в троичной системе эффективнее в 1,5 раза чем в двоичной.</p>

<table>
<thead>
<tr>
<td colspan="2">Кодирование в троичной системе</td>
<td colspan="2">Кодирование в двоичной системе</td>
<td rowspan="2">Соотношение</td>
</tr>
<tr>
<td>Уровень</td>
<td>Максимальное количество элементов</td>
<td>Уровень</td>
<td>Максимальное количество элементов</td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>1.000</td>
</tr>
<tr>
<td>2</td>
<td>9</td>
<td>3</td>
<td>8</td>
<td>1.500</td>
</tr>
<tr>
<td>3</td>
<td>27</td>
<td>4</td>
<td>16</td>
<td>1.333</td>
</tr>
<tr>
<td>4</td>
<td>81</td>
<td>6</td>
<td>64</td>
<td>1.500</td>
</tr>
<tr>
<td>5</td>
<td>243</td>
<td>7</td>
<td>128</td>
<td>1.400</td>
</tr>
<tr>
<td>6</td>
<td>729</td>
<td>9</td>
<td>512</td>
<td>1.500</td>
</tr>
<tr>
<td>7</td>
<td>2187</td>
<td>11</td>
<td>2048</td>
<td>1.571</td>
</tr>
<tr>
<td>8</td>
<td>6561</td>
<td>12</td>
<td>4096</td>
<td>1.500</td>
</tr>
<tr>
<td>9</td>
<td>19683</td>
<td>14</td>
<td>16384</td>
<td>1.556</td>
</tr>
<tr>
<td>10</td>
<td>59049</td>
<td>15</td>
<td>32768</td>
<td>1.500</td>
</tr>
<tr>
<td>11</td>
<td>177147</td>
<td>17</td>
<td>131072</td>
<td>1.545</td>
</tr>
<tr>
<td>12</td>
<td>531441</td>
<td>19</td>
<td>524288</td>
<td>1.583</td>
</tr>
<tr>
<td>13</td>
<td>1594323</td>
<td>20</td>
<td>1048576</td>
<td>1.538</td>
</tr>
<tr>
<td>14</td>
<td>4782969</td>
<td>22</td>
<td>4194304</td>
<td>1.571</td>
</tr>
<tr>
<td>15</td>
<td>14348907</td>
<td>23</td>
<td>8388608</td>
<td>1.533</td>
</tr>
<tr>
<td>16</td>
<td>43046721</td>
<td>25</td>
<td>33554432</td>
<td>1.562</td>
</tr>
<tr>
<td>17</td>
<td>129140163</td>
<td>26</td>
<td>67108864</td>
<td>1.529</td>
</tr>
<tr>
<td>18</td>
<td>387420489</td>
<td>28</td>
<td>268435456</td>
<td>1.556</td>
</tr>
<tr>
<td>19</td>
<td>1162261467</td>
<td>30</td>
<td>1073741824</td>
<td>1.579</td>
</tr>
<tr>
<td>20</td>
<td>3486784401</td>
<td>31</td>
<td>2147483648</td>
<td>1.550</td>
</tr>
<tr>
<td>21</td>
<td>10460353203</td>
<td>33</td>
<td>8589934592</td>
<td>1.571</td>
</tr>
<tr>
<td>22</td>
<td>31381059609</td>
<td>34</td>
<td>17179869184</td>
<td>1.545</td>
</tr>
<tr>
<td>23</td>
<td>94143178827</td>
<td>36</td>
<td>68719476736</td>
<td>1.565</td>
</tr>
<tr>
<td>24</td>
<td>282429536481</td>
<td>38</td>
<td>274877906944</td>
<td>1.583</td>
</tr>
<tr>
<td>25</td>
<td>847288609443</td>
<td>39</td>
<td>549755813888</td>
<td>1.560</td>
</tr>
<tr>
<td>26</td>
<td>2541865828329</td>
<td>41</td>
<td>2199023255552</td>
<td>1.577</td>
</tr>
<tr>
<td>27</td>
<td>7625597484987</td>
<td>42</td>
<td>4398046511104</td>
<td>1.556</td>
</tr>
<tr>
<td>28</td>
<td>22876792454961</td>
<td>44</td>
<td>17592186044416</td>
<td>1.571</td>
</tr>
<tr>
<td>29</td>
<td>68630377364883</td>
<td>45</td>
<td>35184372088832</td>
<td>1.552</td>
</tr>
</tbody>
</table>

<h2>Выводы</h2>
<p>Построение троичного дерева в два раза быстрее (по количеству шагов) и в полтора раза эффективнее (по длине кодов), чем двоичное дерево.</p>
<h2>Источники</h2>
<ol>
<li>Семенюк В. В. Экономное кодирование дискретной информации. – СПб.: СПбГИТМО (ТУ), 2001. – 115 с.<br />УДК 621.391:519.726<br />ISBN 5–7577–0076–9</li>
<li>http://www.compression.ru</li>
</ol>
